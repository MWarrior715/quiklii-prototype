import jwt from 'jsonwebtoken';
import {
  ROOM_TYPES,
  ROOM_CONFIG,
  CONNECTION_EVENTS,
  SYSTEM_EVENTS,
  ERROR_CODES
} from '../utils/constants.js';

/**
 * Sistema avanzado de gesti√≥n de salas (rooms) para WebSockets
 * Maneja creaci√≥n, limpieza autom√°tica, l√≠mites y monitoreo de salas
 */
export class RoomManager {
  constructor(io) {
    this.io = io;
    this.rooms = new Map(); // Almacena informaci√≥n de las salas
    this.userRooms = new Map(); // Almacena salas por usuario
    this.roomUsers = new Map(); // Almacena usuarios por sala
    this.cleanupInterval = null;

    this.initializeCleanup();
    this.setupEventHandlers();
  }

  /**
   * Inicializa el sistema de limpieza autom√°tica de salas
   */
  initializeCleanup() {
    this.cleanupInterval = setInterval(() => {
      this.cleanupInactiveRooms();
    }, ROOM_CONFIG.AUTO_CLEANUP_INTERVAL);
  }

  /**
   * Configura manejadores de eventos para monitoreo
   */
  setupEventHandlers() {
    this.io.on(CONNECTION_EVENTS.CONNECT, (socket) => {
      this.handleSocketConnection(socket);
    });

    this.io.on(CONNECTION_EVENTS.DISCONNECT, (socket) => {
      this.handleSocketDisconnection(socket);
    });
  }

  /**
   * Maneja nueva conexi√≥n de socket
   */
  handleSocketConnection(socket) {
    console.log(`üîó Nueva conexi√≥n: ${socket.id}`);

    // Configurar heartbeat para esta conexi√≥n
    this.setupHeartbeat(socket);

    // Manejar eventos de autenticaci√≥n
    socket.on(CONNECTION_EVENTS.AUTHENTICATE, (data) => {
      this.handleAuthentication(socket, data);
    });

    // Manejar uni√≥n a salas
    socket.on(CONNECTION_EVENTS.JOIN_ROOM, (data) => {
      this.handleJoinRoom(socket, data);
    });

    // Manejar salida de salas
    socket.on(CONNECTION_EVENTS.LEAVE_ROOM, (data) => {
      this.handleLeaveRoom(socket, data);
    });
  }

  /**
   * Maneja desconexi√≥n de socket
   */
  handleSocketDisconnection(socket) {
    console.log(`üîå Desconexi√≥n: ${socket.id}`);

    // Remover usuario de todas sus salas
    if (socket.userId) {
      this.removeUserFromAllRooms(socket.userId, socket.id);
    }

    // Limpiar heartbeat
    if (socket.heartbeatInterval) {
      clearInterval(socket.heartbeatInterval);
    }
  }

  /**
   * Configura heartbeat para mantener conexi√≥n activa
   */
  setupHeartbeat(socket) {
    socket.heartbeatInterval = setInterval(() => {
      socket.emit('ping', { timestamp: new Date() });
      socket.heartbeatTimeout = setTimeout(() => {
        console.log(`üíî Heartbeat timeout para ${socket.id}`);
        socket.disconnect();
      }, 5000);
    }, 30000);

    socket.on('pong', (data) => {
      if (socket.heartbeatTimeout) {
        clearTimeout(socket.heartbeatTimeout);
      }
    });
  }

  /**
   * Maneja autenticaci√≥n de usuario
   */
  handleAuthentication(socket, data) {
    try {
      const { token } = data;

      if (!token) {
        socket.emit(CONNECTION_EVENTS.AUTHENTICATION_FAILED, {
          error: 'Token requerido',
          code: ERROR_CODES.INVALID_CREDENTIALS
        });
        return;
      }

      // Verificar token JWT
      const decoded = jwt.verify(token, process.env.JWT_SECRET);

      socket.userId = decoded.id;
      socket.userRole = decoded.role;
      socket.userEmail = decoded.email;

      // Inicializar mapa de salas para el usuario
      if (!this.userRooms.has(socket.userId)) {
        this.userRooms.set(socket.userId, new Set());
      }

      socket.emit(CONNECTION_EVENTS.AUTHENTICATION_SUCCESS, {
        userId: socket.userId,
        role: socket.userRole,
        message: 'Autenticaci√≥n exitosa'
      });

      console.log(`‚úÖ Usuario autenticado: ${socket.userId} (${socket.userRole})`);

    } catch (error) {
      console.error('‚ùå Error de autenticaci√≥n:', error);
      socket.emit(CONNECTION_EVENTS.AUTHENTICATION_FAILED, {
        error: 'Token inv√°lido',
        code: ERROR_CODES.INVALID_CREDENTIALS
      });
    }
  }

  /**
   * Maneja uni√≥n a una sala
   */
  handleJoinRoom(socket, data) {
    try {
      const { roomName, roomType } = data;

      if (!roomName) {
        socket.emit('error', { message: 'Nombre de sala requerido' });
        return;
      }

      // Validar autenticaci√≥n
      if (!socket.userId) {
        socket.emit('error', { message: 'Usuario no autenticado' });
        return;
      }

      // Unirse a la sala
      socket.join(roomName);

      // Registrar en el sistema de gesti√≥n
      this.addUserToRoom(socket.userId, socket.id, roomName, roomType);

      socket.emit(CONNECTION_EVENTS.ROOM_JOINED, {
        roomName,
        roomType,
        message: `Unido a sala: ${roomName}`
      });

      console.log(`üë§ Usuario ${socket.userId} se uni√≥ a sala: ${roomName}`);

    } catch (error) {
      console.error('‚ùå Error al unir a sala:', error);
      socket.emit('error', { message: 'Error al unir a sala' });
    }
  }

  /**
   * Maneja salida de una sala
   */
  handleLeaveRoom(socket, data) {
    try {
      const { roomName } = data;

      if (!roomName) {
        socket.emit('error', { message: 'Nombre de sala requerido' });
        return;
      }

      // Salir de la sala
      socket.leave(roomName);

      // Remover del sistema de gesti√≥n
      this.removeUserFromRoom(socket.userId, socket.id, roomName);

      socket.emit(CONNECTION_EVENTS.ROOM_LEFT, {
        roomName,
        message: `Abandonada sala: ${roomName}`
      });

      console.log(`üë§ Usuario ${socket.userId} abandon√≥ sala: ${roomName}`);

    } catch (error) {
      console.error('‚ùå Error al abandonar sala:', error);
      socket.emit('error', { message: 'Error al abandonar sala' });
    }
  }

  /**
   * Agrega usuario a una sala
   */
  addUserToRoom(userId, socketId, roomName, roomType = null) {
    // Inicializar sala si no existe
    if (!this.rooms.has(roomName)) {
      this.rooms.set(roomName, {
        name: roomName,
        type: roomType,
        users: new Set(),
        createdAt: new Date(),
        lastActivity: new Date()
      });
    }

    // Agregar usuario a la sala
    const room = this.rooms.get(roomName);
    room.users.add(socketId);
    room.lastActivity = new Date();

    // Agregar sala al usuario
    if (!this.userRooms.has(userId)) {
      this.userRooms.set(userId, new Set());
    }
    this.userRooms.get(userId).add(roomName);

    // Inicializar usuarios en sala si no existe
    if (!this.roomUsers.has(roomName)) {
      this.roomUsers.set(roomName, new Set());
    }
    this.roomUsers.get(roomName).add(userId);

    // Verificar l√≠mites
    this.checkRoomLimits(roomName);
  }

  /**
   * Remueve usuario de una sala
   */
  removeUserFromRoom(userId, socketId, roomName) {
    // Remover de la sala
    if (this.rooms.has(roomName)) {
      const room = this.rooms.get(roomName);
      room.users.delete(socketId);
      room.lastActivity = new Date();

      // Si la sala est√° vac√≠a, marcar para limpieza
      if (room.users.size === 0) {
        room.emptySince = new Date();
      }
    }

    // Remover sala del usuario
    if (this.userRooms.has(userId)) {
      this.userRooms.get(userId).delete(roomName);
    }

    // Remover usuario de la sala
    if (this.roomUsers.has(roomName)) {
      this.roomUsers.get(roomName).delete(userId);
    }
  }

  /**
   * Remueve usuario de todas sus salas
   */
  removeUserFromAllRooms(userId, socketId) {
    if (this.userRooms.has(userId)) {
      const userRoomList = Array.from(this.userRooms.get(userId));
      userRoomList.forEach(roomName => {
        this.removeUserFromRoom(userId, socketId, roomName);
      });
      this.userRooms.delete(userId);
    }
  }

  /**
   * Verifica l√≠mites de usuarios por sala
   */
  checkRoomLimits(roomName) {
    const room = this.rooms.get(roomName);
    if (room && room.users.size > ROOM_CONFIG.MAX_USERS_PER_ROOM) {
      console.warn(`‚ö†Ô∏è Sala ${roomName} alcanz√≥ l√≠mite m√°ximo de usuarios`);
      // Podr√≠a implementar l√≥gica de rechazo aqu√≠
    }
  }

  /**
   * Limpia salas inactivas
   */
  cleanupInactiveRooms() {
    const now = new Date();
    const roomsToDelete = [];

    for (const [roomName, room] of this.rooms.entries()) {
      // Si la sala est√° vac√≠a por m√°s del tiempo l√≠mite
      if (room.users.size === 0 && room.emptySince) {
        const emptyTime = now - room.emptySince;
        if (emptyTime > ROOM_CONFIG.INACTIVE_ROOM_TIMEOUT) {
          roomsToDelete.push(roomName);
        }
      }
    }

    // Eliminar salas inactivas
    roomsToDelete.forEach(roomName => {
      this.rooms.delete(roomName);
      this.roomUsers.delete(roomName);
      console.log(`üßπ Sala inactiva eliminada: ${roomName}`);
    });

    if (roomsToDelete.length > 0) {
      console.log(`üßπ Limpieza completada: ${roomsToDelete.length} salas eliminadas`);
    }
  }

  /**
   * Crea salas espec√≠ficas para un pedido
   */
  createOrderRooms(orderId) {
    const rooms = [
      `order_${orderId}`,
      `order_${orderId}_tracking`
    ];

    rooms.forEach(roomName => {
      if (!this.rooms.has(roomName)) {
        this.rooms.set(roomName, {
          name: roomName,
          type: ROOM_TYPES.ORDER_ROOM,
          users: new Set(),
          createdAt: new Date(),
          lastActivity: new Date()
        });
      }
    });

    return rooms;
  }

  /**
   * Crea salas espec√≠ficas para un restaurante
   */
  createRestaurantRooms(restaurantId) {
    const rooms = [
      `restaurant_${restaurantId}`,
      `restaurant_${restaurantId}_orders`,
      `restaurant_${restaurantId}_kitchen`
    ];

    rooms.forEach(roomName => {
      if (!this.rooms.has(roomName)) {
        this.rooms.set(roomName, {
          name: roomName,
          type: ROOM_TYPES.RESTAURANT_ROOM,
          users: new Set(),
          createdAt: new Date(),
          lastActivity: new Date()
        });
      }
    });

    return rooms;
  }

  /**
   * Crea salas espec√≠ficas para un repartidor
   */
  createDeliveryRooms(deliveryPersonId) {
    const rooms = [
      `delivery_${deliveryPersonId}`,
      `delivery_active_${deliveryPersonId}`
    ];

    rooms.forEach(roomName => {
      if (!this.rooms.has(roomName)) {
        this.rooms.set(roomName, {
          name: roomName,
          type: ROOM_TYPES.DELIVERY_PERSONAL,
          users: new Set(),
          createdAt: new Date(),
          lastActivity: new Date()
        });
      }
    });

    return rooms;
  }

  /**
   * Obtiene informaci√≥n de una sala
   */
  getRoomInfo(roomName) {
    return this.rooms.get(roomName) || null;
  }

  /**
   * Obtiene todas las salas de un usuario
   */
  getUserRooms(userId) {
    return Array.from(this.userRooms.get(userId) || []);
  }

  /**
   * Obtiene usuarios en una sala
   */
  getRoomUsers(roomName) {
    return Array.from(this.roomUsers.get(roomName) || []);
  }

  /**
   * Obtiene estad√≠sticas del sistema de salas
   */
  getStats() {
    return {
      totalRooms: this.rooms.size,
      totalUsers: this.userRooms.size,
      roomsByType: this.getRoomsByType(),
      memoryUsage: {
        rooms: this.rooms.size * 100, // Aproximado en bytes
        userRooms: this.userRooms.size * 50,
        roomUsers: this.roomUsers.size * 50
      }
    };
  }

  /**
   * Obtiene salas agrupadas por tipo
   */
  getRoomsByType() {
    const stats = {};

    for (const [roomName, room] of this.rooms.entries()) {
      const type = room.type || 'unknown';
      if (!stats[type]) {
        stats[type] = 0;
      }
      stats[type]++;
    }

    return stats;
  }

  /**
   * Emite evento a una sala espec√≠fica
   */
  emitToRoom(roomName, event, data) {
    this.io.to(roomName).emit(event, {
      ...data,
      timestamp: new Date(),
      room: roomName
    });

    // Actualizar actividad de la sala
    if (this.rooms.has(roomName)) {
      this.rooms.get(roomName).lastActivity = new Date();
    }
  }

  /**
   * Emite evento a m√∫ltiples salas
   */
  emitToRooms(roomNames, event, data) {
    roomNames.forEach(roomName => {
      this.emitToRoom(roomName, event, data);
    });
  }

  /**
   * Emite evento a todas las salas de un usuario
   */
  emitToUserRooms(userId, event, data) {
    const userRoomList = this.getUserRooms(userId);
    this.emitToRooms(userRoomList, event, data);
  }

  /**
   * Obtiene salas activas (con usuarios)
   */
  getActiveRooms() {
    const activeRooms = [];

    for (const [roomName, room] of this.rooms.entries()) {
      if (room.users.size > 0) {
        activeRooms.push({
          name: roomName,
          type: room.type,
          userCount: room.users.size,
          createdAt: room.createdAt,
          lastActivity: room.lastActivity
        });
      }
    }

    return activeRooms;
  }

  /**
   * Cierra el sistema de gesti√≥n de salas
   */
  close() {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
    }

    // Limpiar todas las estructuras de datos
    this.rooms.clear();
    this.userRooms.clear();
    this.roomUsers.clear();

    console.log('üîÑ RoomManager cerrado');
  }
}

// Funci√≥n para inicializar el RoomManager
export const initializeRoomManager = (io) => {
  return new RoomManager(io);
};